// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package dbsqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const assignTesterToProject = `-- name: AssignTesterToProject :execrows
INSERT INTO project_testers (
    project_id, user_id, role, is_active, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, now(), now()
)
`

type AssignTesterToProjectParams struct {
	ProjectID int32
	UserID    int32
	Role      string
	IsActive  bool
}

func (q *Queries) AssignTesterToProject(ctx context.Context, arg AssignTesterToProjectParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, assignTesterToProject,
		arg.ProjectID,
		arg.UserID,
		arg.Role,
		arg.IsActive,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const changeUserPassword = `-- name: ChangeUserPassword :exec
UPDATE users
SET password = $2, updated_at = $3
WHERE id = $1
`

type ChangeUserPasswordParams struct {
	ID        int32
	Password  string
	UpdatedAt sql.NullTime
}

func (q *Queries) ChangeUserPassword(ctx context.Context, arg ChangeUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, changeUserPassword, arg.ID, arg.Password, arg.UpdatedAt)
	return err
}

const closeTestPlan = `-- name: CloseTestPlan :execrows
UPDATE test_plans
SET is_complete = TRUE,
closed_at = $2,
updated_at = $2
WHERE id = $1
`

type CloseTestPlanParams struct {
	ID       int64
	ClosedAt sql.NullTime
}

func (q *Queries) CloseTestPlan(ctx context.Context, arg CloseTestPlanParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, closeTestPlan, arg.ID, arg.ClosedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const closeTestRun = `-- name: CloseTestRun :exec
UPDATE test_runs
SET is_closed = TRUE,
updated_at = NOW()
WHERE id = $1
`

func (q *Queries) CloseTestRun(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, closeTestRun, id)
	return err
}

const commitTestRunResult = `-- name: CommitTestRunResult :one
UPDATE test_runs SET
    tested_by_id = $2,
    updated_at = $3,
    result_state = $4,
    is_closed = $5,
    notes = $6,
    tested_on = $7,
    actual_result = $8,
    expected_result = $9
WHERE id = $1
RETURNING id
`

type CommitTestRunResultParams struct {
	ID             uuid.UUID
	TestedByID     int32
	UpdatedAt      sql.NullTime
	ResultState    TestRunState
	IsClosed       sql.NullBool
	Notes          string
	TestedOn       time.Time
	ActualResult   sql.NullString
	ExpectedResult sql.NullString
}

func (q *Queries) CommitTestRunResult(ctx context.Context, arg CommitTestRunResultParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, commitTestRunResult,
		arg.ID,
		arg.TestedByID,
		arg.UpdatedAt,
		arg.ResultState,
		arg.IsClosed,
		arg.Notes,
		arg.TestedOn,
		arg.ActualResult,
		arg.ExpectedResult,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const countTestCasesNotLinkedToProject = `-- name: CountTestCasesNotLinkedToProject :one
SELECT COUNT(*) FROM test_cases
RIGHT OUTER JOIN test_plans p ON p.test_case_id = test_cases.id
WHERE p.project_id IS NULL
`

func (q *Queries) CountTestCasesNotLinkedToProject(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTestCasesNotLinkedToProject)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (
    project_id, name, description, base_url, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, now(), now()
) RETURNING id
`

type CreateEnvironmentParams struct {
	ProjectID   sql.NullInt32
	Name        string
	Description sql.NullString
	BaseUrl     sql.NullString
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createEnvironment,
		arg.ProjectID,
		arg.Name,
		arg.Description,
		arg.BaseUrl,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createInvite = `-- name: CreateInvite :exec
INSERT INTO invites (sender_email, receiver_email, token, expires_at)
VALUES ($1, $2, $3, $4)
`

type CreateInviteParams struct {
	SenderEmail   string
	ReceiverEmail string
	Token         string
	ExpiresAt     sql.NullTime
}

func (q *Queries) CreateInvite(ctx context.Context, arg CreateInviteParams) error {
	_, err := q.db.ExecContext(ctx, createInvite,
		arg.SenderEmail,
		arg.ReceiverEmail,
		arg.Token,
		arg.ExpiresAt,
	)
	return err
}

const createNewTestRun = `-- name: CreateNewTestRun :one
INSERT INTO test_runs (
id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, code, created_at, updated_at,
result_state, is_closed, assignee_can_change_code, notes,reactions, tested_on, expected_result
)
VALUES (
$1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
'pending', false, false, 'None', '{}'::jsonb, now(), 'Test to Pass'
)
RETURNING id
`

type CreateNewTestRunParams struct {
	ID           uuid.UUID
	ProjectID    int32
	TestPlanID   int32
	TestCaseID   uuid.UUID
	OwnerID      int32
	TestedByID   int32
	AssignedToID int32
	Code         string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) CreateNewTestRun(ctx context.Context, arg CreateNewTestRunParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createNewTestRun,
		arg.ID,
		arg.ProjectID,
		arg.TestPlanID,
		arg.TestCaseID,
		arg.OwnerID,
		arg.TestedByID,
		arg.AssignedToID,
		arg.Code,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createPage = `-- name: CreatePage :one
INSERT INTO pages(parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at
) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, now(), now(), now()) RETURNING id, parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at
`

type CreatePageParams struct {
	ParentPageID       sql.NullInt32
	PageVersion        string
	OrgID              int32
	ProjectID          int32
	Code               string
	Title              string
	FilePath           sql.NullString
	Content            string
	PageType           string
	MimeType           string
	HasEmbeddedMedia   bool
	ExternalContentUrl sql.NullString
	NotionUrl          sql.NullString
	LastEditedBy       int32
	CreatedBy          int32
}

func (q *Queries) CreatePage(ctx context.Context, arg CreatePageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, createPage,
		arg.ParentPageID,
		arg.PageVersion,
		arg.OrgID,
		arg.ProjectID,
		arg.Code,
		arg.Title,
		arg.FilePath,
		arg.Content,
		arg.PageType,
		arg.MimeType,
		arg.HasEmbeddedMedia,
		arg.ExternalContentUrl,
		arg.NotionUrl,
		arg.LastEditedBy,
		arg.CreatedBy,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.ParentPageID,
		&i.PageVersion,
		&i.OrgID,
		&i.ProjectID,
		&i.Code,
		&i.Title,
		&i.FilePath,
		&i.Content,
		&i.PageType,
		&i.MimeType,
		&i.HasEmbeddedMedia,
		&i.ExternalContentUrl,
		&i.NotionUrl,
		&i.LastEditedBy,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    title, description, version, is_active, is_public, website_url,
    github_url, trello_url, jira_url, monday_url,
    owner_user_id, created_at, updated_at, deleted_at
)
VALUES(
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13, $14
) RETURNING id
`

type CreateProjectParams struct {
	Title       string
	Description string
	Version     sql.NullString
	IsActive    sql.NullBool
	IsPublic    sql.NullBool
	WebsiteUrl  sql.NullString
	GithubUrl   sql.NullString
	TrelloUrl   sql.NullString
	JiraUrl     sql.NullString
	MondayUrl   sql.NullString
	OwnerUserID int32
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Title,
		arg.Description,
		arg.Version,
		arg.IsActive,
		arg.IsPublic,
		arg.WebsiteUrl,
		arg.GithubUrl,
		arg.TrelloUrl,
		arg.JiraUrl,
		arg.MondayUrl,
		arg.OwnerUserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createProjectModules = `-- name: CreateProjectModules :one
INSERT INTO modules(
    project_id, name, code, priority, type, description, created_at, updated_at
)VALUES($1, $2, $3, $4, $5, $6, now(), now()
)
RETURNING id, project_id, name, code, priority, type, description, created_at, updated_at
`

type CreateProjectModulesParams struct {
	ProjectID   int32
	Name        string
	Code        string
	Priority    int32
	Type        string
	Description string
}

func (q *Queries) CreateProjectModules(ctx context.Context, arg CreateProjectModulesParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, createProjectModules,
		arg.ProjectID,
		arg.Name,
		arg.Code,
		arg.Priority,
		arg.Type,
		arg.Description,
	)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Code,
		&i.Priority,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO test_cases (
    id, kind, code, feature_or_module, title, description, parent_test_case_id,
    is_draft, tags, created_by_id, created_at, updated_at, project_id
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13
)
RETURNING id
`

type CreateTestCaseParams struct {
	ID               uuid.UUID
	Kind             TestKind
	Code             string
	FeatureOrModule  sql.NullString
	Title            string
	Description      string
	ParentTestCaseID sql.NullInt32
	IsDraft          sql.NullBool
	Tags             []string
	CreatedByID      int32
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ProjectID        sql.NullInt32
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createTestCase,
		arg.ID,
		arg.Kind,
		arg.Code,
		arg.FeatureOrModule,
		arg.Title,
		arg.Description,
		arg.ParentTestCaseID,
		arg.IsDraft,
		pq.Array(arg.Tags),
		arg.CreatedByID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProjectID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createTestPlan = `-- name: CreateTestPlan :one
INSERT INTO test_plans (
    project_id, assigned_to_id, created_by_id, updated_by_id,
    kind, description, start_at, closed_at, scheduled_end_at,
    num_test_cases, num_failures, is_complete, is_locked, has_report,
    created_at, updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $7, $8,
    $9, $10, $11, $12, $13, $14, $15
)
RETURNING id
`

type CreateTestPlanParams struct {
	ProjectID      int32
	AssignedToID   int32
	CreatedByID    int32
	UpdatedByID    int32
	Kind           TestKind
	Description    sql.NullString
	StartAt        sql.NullTime
	ScheduledEndAt sql.NullTime
	NumTestCases   int32
	NumFailures    int32
	IsComplete     sql.NullBool
	IsLocked       sql.NullBool
	HasReport      sql.NullBool
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
}

func (q *Queries) CreateTestPlan(ctx context.Context, arg CreateTestPlanParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createTestPlan,
		arg.ProjectID,
		arg.AssignedToID,
		arg.CreatedByID,
		arg.UpdatedByID,
		arg.Kind,
		arg.Description,
		arg.StartAt,
		arg.ScheduledEndAt,
		arg.NumTestCases,
		arg.NumFailures,
		arg.IsComplete,
		arg.IsLocked,
		arg.HasReport,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    first_name, last_name, display_name, email, password, phone,
    org_id, country_iso, city, address,
    is_activated, is_reviewed, is_super_admin, is_verified,
    last_login_at, email_confirmed_at, created_at, updated_at, deleted_at
)
VALUES(
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17, $18, $19
)
RETURNING id
`

type CreateUserParams struct {
	FirstName        string
	LastName         string
	DisplayName      sql.NullString
	Email            string
	Password         string
	Phone            string
	OrgID            sql.NullInt32
	CountryIso       string
	City             sql.NullString
	Address          string
	IsActivated      sql.NullBool
	IsReviewed       sql.NullBool
	IsSuperAdmin     sql.NullBool
	IsVerified       sql.NullBool
	LastLoginAt      sql.NullTime
	EmailConfirmedAt sql.NullTime
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	DeletedAt        sql.NullTime
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.DisplayName,
		arg.Email,
		arg.Password,
		arg.Phone,
		arg.OrgID,
		arg.CountryIso,
		arg.City,
		arg.Address,
		arg.IsActivated,
		arg.IsReviewed,
		arg.IsSuperAdmin,
		arg.IsVerified,
		arg.LastLoginAt,
		arg.EmailConfirmedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAllTestPlansInProject = `-- name: DeleteAllTestPlansInProject :execrows
DELETE FROM test_plans WHERE project_id = $1
`

func (q *Queries) DeleteAllTestPlansInProject(ctx context.Context, projectID int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAllTestPlansInProject, projectID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteAllTestRunsInProject = `-- name: DeleteAllTestRunsInProject :execrows
DELETE FROM test_runs WHERE project_id = $1
`

func (q *Queries) DeleteAllTestRunsInProject(ctx context.Context, projectID int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAllTestRunsInProject, projectID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deletePage = `-- name: DeletePage :execrows
DELETE FROM pages WHERE id = $1
`

func (q *Queries) DeletePage(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePage, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProject = `-- name: DeleteProject :execrows
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProject, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProjectModule = `-- name: DeleteProjectModule :execrows
DELETE FROM modules WHERE id = $1
`

func (q *Queries) DeleteProjectModule(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProjectModule, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProjectTester = `-- name: DeleteProjectTester :execrows
DELETE FROM project_testers WHERE user_id = $1
`

func (q *Queries) DeleteProjectTester(ctx context.Context, userID int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProjectTester, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTestCase = `-- name: DeleteTestCase :execrows
DELETE FROM test_cases WHERE id = $1
`

func (q *Queries) DeleteTestCase(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTestCase, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTestPlan = `-- name: DeleteTestPlan :execrows
DELETE FROM test_plans WHERE id = $1
`

func (q *Queries) DeleteTestPlan(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTestPlan, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTestRun = `-- name: DeleteTestRun :execrows
DELETE FROM test_runs WHERE id = $1
`

func (q *Queries) DeleteTestRun(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTestRun, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteUser = `-- name: DeleteUser :execrows
DELETE FROM users WHERE id=$1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const executeTestRun = `-- name: ExecuteTestRun :exec
UPDATE test_runs
SET result_state = $2,
tested_by_id = $3,
notes = $4,
actual_result = $5,
expected_result = $6,
tested_on = NOW(),
updated_at = NOW()
WHERE id = $1
`

type ExecuteTestRunParams struct {
	ID             uuid.UUID
	ResultState    TestRunState
	TestedByID     int32
	Notes          string
	ActualResult   sql.NullString
	ExpectedResult sql.NullString
}

func (q *Queries) ExecuteTestRun(ctx context.Context, arg ExecuteTestRunParams) error {
	_, err := q.db.ExecContext(ctx, executeTestRun,
		arg.ID,
		arg.ResultState,
		arg.TestedByID,
		arg.Notes,
		arg.ActualResult,
		arg.ExpectedResult,
	)
	return err
}

const findUserLoginByEmail = `-- name: FindUserLoginByEmail :one
SELECT id, display_name, email, password, last_login_at FROM users WHERE email = $1 AND is_activated AND deleted_at IS NULL
`

type FindUserLoginByEmailRow struct {
	ID          int32
	DisplayName sql.NullString
	Email       string
	Password    string
	LastLoginAt sql.NullTime
}

func (q *Queries) FindUserLoginByEmail(ctx context.Context, email string) (FindUserLoginByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, findUserLoginByEmail, email)
	var i FindUserLoginByEmailRow
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Email,
		&i.Password,
		&i.LastLoginAt,
	)
	return i, err
}

const getAllModules = `-- name: GetAllModules :many
SELECT id, project_id, name, code, priority, type, description, created_at, updated_at FROM modules
ORDER BY created_at DESC
`

func (q *Queries) GetAllModules(ctx context.Context) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, getAllModules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Code,
			&i.Priority,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPages = `-- name: GetAllPages :many
SELECT id, parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at FROM pages
ORDER BY created_at DESC
`

func (q *Queries) GetAllPages(ctx context.Context) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, getAllPages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.ParentPageID,
			&i.PageVersion,
			&i.OrgID,
			&i.ProjectID,
			&i.Code,
			&i.Title,
			&i.FilePath,
			&i.Content,
			&i.PageType,
			&i.MimeType,
			&i.HasEmbeddedMedia,
			&i.ExternalContentUrl,
			&i.NotionUrl,
			&i.LastEditedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectTesters = `-- name: GetAllProjectTesters :many
SELECT
    pt.id, pt.project_id, pt.user_id, pt.role, pt.is_active, pt.created_at, pt.updated_at,
    p.title AS project,
    u.display_name AS tester_name,
    u.email AS tester_email,
    u.last_login_at AS tester_last_login_at
FROM project_testers pt
INNER JOIN users u ON u.id = pt.user_id
INNER JOIN projects p ON p.id = pt.project_id
ORDER BY pt.created_at DESC
`

type GetAllProjectTestersRow struct {
	ID                int32
	ProjectID         int32
	UserID            int32
	Role              string
	IsActive          bool
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	Project           string
	TesterName        sql.NullString
	TesterEmail       string
	TesterLastLoginAt sql.NullTime
}

func (q *Queries) GetAllProjectTesters(ctx context.Context) ([]GetAllProjectTestersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllProjectTesters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectTestersRow
	for rows.Next() {
		var i GetAllProjectTestersRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Project,
			&i.TesterName,
			&i.TesterEmail,
			&i.TesterLastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnvironment = `-- name: GetEnvironment :one
SELECT id, project_id, name, description, base_url, created_at, updated_at FROM environments WHERE id = $1
`

func (q *Queries) GetEnvironment(ctx context.Context, id int32) (Environment, error) {
	row := q.db.QueryRowContext(ctx, getEnvironment, id)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.BaseUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestCodeByPrefix = `-- name: GetLatestCodeByPrefix :one
SELECT code FROM test_cases
WHERE code LIKE $1 || '%'
ORDER BY code DESC
LIMIT 1
FOR UPDATE
`

func (q *Queries) GetLatestCodeByPrefix(ctx context.Context, dollar_1 sql.NullString) (string, error) {
	row := q.db.QueryRowContext(ctx, getLatestCodeByPrefix, dollar_1)
	var code string
	err := row.Scan(&code)
	return code, err
}

const getNextTestCaseSequence = `-- name: GetNextTestCaseSequence :one
UPDATE test_case_sequences
SET current_val = current_val +1,
last_generated_at = now()
WHERE project_id = $1 AND prefix = $2
RETURNING current_val
`

type GetNextTestCaseSequenceParams struct {
	ProjectID int32
	Prefix    string
}

func (q *Queries) GetNextTestCaseSequence(ctx context.Context, arg GetNextTestCaseSequenceParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextTestCaseSequence, arg.ProjectID, arg.Prefix)
	var current_val int32
	err := row.Scan(&current_val)
	return current_val, err
}

const getOneModule = `-- name: GetOneModule :one
SELECT id, project_id, name, code, priority, type, description, created_at, updated_at FROM modules
WHERE id = $1
`

func (q *Queries) GetOneModule(ctx context.Context, id int32) (Module, error) {
	row := q.db.QueryRowContext(ctx, getOneModule, id)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Code,
		&i.Priority,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPage = `-- name: GetPage :one
SELECT id, parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at FROM pages WHERE id = $1
`

func (q *Queries) GetPage(ctx context.Context, id int32) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPage, id)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.ParentPageID,
		&i.PageVersion,
		&i.OrgID,
		&i.ProjectID,
		&i.Code,
		&i.Title,
		&i.FilePath,
		&i.Content,
		&i.PageType,
		&i.MimeType,
		&i.HasEmbeddedMedia,
		&i.ExternalContentUrl,
		&i.NotionUrl,
		&i.LastEditedBy,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProject = `-- name: GetProject :one
SELECT id, title, description, version, is_active, is_public, website_url, github_url, trello_url, jira_url, monday_url, owner_user_id, created_at, updated_at, deleted_at, code FROM projects WHERE id = $1
`

func (q *Queries) GetProject(ctx context.Context, id int32) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Version,
		&i.IsActive,
		&i.IsPublic,
		&i.WebsiteUrl,
		&i.GithubUrl,
		&i.TrelloUrl,
		&i.JiraUrl,
		&i.MondayUrl,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Code,
	)
	return i, err
}

const getProjectCount = `-- name: GetProjectCount :one
SELECT COUNT(*) FROM projects
`

func (q *Queries) GetProjectCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProjectCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectModules = `-- name: GetProjectModules :many
SELECT id, project_id, name, code, priority, type, description, created_at, updated_at FROM modules
WHERE project_id = $1
`

func (q *Queries) GetProjectModules(ctx context.Context, projectID int32) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, getProjectModules, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Code,
			&i.Priority,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentProjects = `-- name: GetRecentProjects :many
SELECT id, title AS name, updated_at
FROM projects
ORDER BY updated_at DESC
LIMIT 5
`

type GetRecentProjectsRow struct {
	ID        int32
	Name      string
	UpdatedAt time.Time
}

func (q *Queries) GetRecentProjects(ctx context.Context) ([]GetRecentProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentProjectsRow
	for rows.Next() {
		var i GetRecentProjectsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCase = `-- name: GetTestCase :one
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE id = $1
`

func (q *Queries) GetTestCase(ctx context.Context, id uuid.UUID) (TestCase, error) {
	row := q.db.QueryRowContext(ctx, getTestCase, id)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Code,
		&i.FeatureOrModule,
		&i.Title,
		&i.Description,
		&i.ParentTestCaseID,
		&i.IsDraft,
		pq.Array(&i.Tags),
		&i.CreatedByID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
	)
	return i, err
}

const getTestCaseByCode = `-- name: GetTestCaseByCode :one
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases
WHERE project_id = $1 AND code = $2
`

type GetTestCaseByCodeParams struct {
	ProjectID sql.NullInt32
	Code      string
}

func (q *Queries) GetTestCaseByCode(ctx context.Context, arg GetTestCaseByCodeParams) (TestCase, error) {
	row := q.db.QueryRowContext(ctx, getTestCaseByCode, arg.ProjectID, arg.Code)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Code,
		&i.FeatureOrModule,
		&i.Title,
		&i.Description,
		&i.ParentTestCaseID,
		&i.IsDraft,
		pq.Array(&i.Tags),
		&i.CreatedByID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
	)
	return i, err
}

const getTestCaseCount = `-- name: GetTestCaseCount :one
SELECT COUNT(*) FROM test_cases
`

func (q *Queries) GetTestCaseCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTestCaseCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTestCaseExecutionSummary = `-- name: GetTestCaseExecutionSummary :many
SELECT
    tr.test_case_id,
    COUNT(*) AS usage_count,
    SUM(CASE WHEN trr.status = 'passed' THEN 1 ELSE 0 END) AS success_count,
    SUM(CASE WHEN trr.status = 'failed' THEN 1 ELSE 0 END) AS failure_count
FROM test_run_results trr
INNER JOIN test_runs tr ON tr.id = trr.test_run_id
WHERE trr.executed_by = $1
GROUP BY tr.test_case_id
`

type GetTestCaseExecutionSummaryRow struct {
	TestCaseID   uuid.UUID
	UsageCount   int64
	SuccessCount int64
	FailureCount int64
}

func (q *Queries) GetTestCaseExecutionSummary(ctx context.Context, executedBy int32) ([]GetTestCaseExecutionSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTestCaseExecutionSummary, executedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCaseExecutionSummaryRow
	for rows.Next() {
		var i GetTestCaseExecutionSummaryRow
		if err := rows.Scan(
			&i.TestCaseID,
			&i.UsageCount,
			&i.SuccessCount,
			&i.FailureCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCasesWithPlanInfo = `-- name: GetTestCasesWithPlanInfo :many
SELECT
    tc.id AS test_case_id,
    tc.title,
    tc.project_id,
    tc.created_by_id,
    tc.kind,
    tc.code,
    tc.feature_or_module,
    tc.description,
    tc.is_draft,
    tc.tags,
    tc.created_at,
    tc.updated_at,
    tp.id AS plan_id,
    tp.description AS plan_name,
    array_agg(tr.assigned_to_id)::bigint[] AS tester_ids
FROM test_cases tc
LEFT JOIN test_runs tr ON tr.test_case_id = tc.id
LEFT JOIN test_plans tp ON tp.id = tr.test_plan_id
WHERE tr.test_plan_id = $1
GROUP BY tc.id, tp.id, tp.description
`

type GetTestCasesWithPlanInfoRow struct {
	TestCaseID      uuid.UUID
	Title           string
	ProjectID       sql.NullInt32
	CreatedByID     int32
	Kind            TestKind
	Code            string
	FeatureOrModule sql.NullString
	Description     string
	IsDraft         sql.NullBool
	Tags            []string
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
	PlanID          sql.NullInt64
	PlanName        sql.NullString
	TesterIds       []int64
}

func (q *Queries) GetTestCasesWithPlanInfo(ctx context.Context, testPlanID int32) ([]GetTestCasesWithPlanInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getTestCasesWithPlanInfo, testPlanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCasesWithPlanInfoRow
	for rows.Next() {
		var i GetTestCasesWithPlanInfoRow
		if err := rows.Scan(
			&i.TestCaseID,
			&i.Title,
			&i.ProjectID,
			&i.CreatedByID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Description,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanID,
			&i.PlanName,
			pq.Array(&i.TesterIds),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCasesWithTestersByPlan = `-- name: GetTestCasesWithTestersByPlan :many
SELECT
    tc.id AS test_case_id,
    tc.title,
    tr.test_plan_id,
    array_agg(tr.assigned_to_id)::bigint[] AS tester_ids
FROM test_cases tc
INNER JOIN test_runs tr ON tr.test_case_id = tc.id
WHERE tr.test_plan_id = $1
GROUP BY tc.id, tc.title, tr.test_plan_id
`

type GetTestCasesWithTestersByPlanRow struct {
	TestCaseID uuid.UUID
	Title      string
	TestPlanID int32
	TesterIds  []int64
}

func (q *Queries) GetTestCasesWithTestersByPlan(ctx context.Context, testPlanID int32) ([]GetTestCasesWithTestersByPlanRow, error) {
	rows, err := q.db.QueryContext(ctx, getTestCasesWithTestersByPlan, testPlanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestCasesWithTestersByPlanRow
	for rows.Next() {
		var i GetTestCasesWithTestersByPlanRow
		if err := rows.Scan(
			&i.TestCaseID,
			&i.Title,
			&i.TestPlanID,
			pq.Array(&i.TesterIds),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestPlan = `-- name: GetTestPlan :one
SELECT tp.id, tp.project_id, tp.assigned_to_id, tp.created_by_id, tp.updated_by_id,
       tp.kind, tp.description, tp.start_at, tp.closed_at, tp.scheduled_end_at,
       tp.num_failures, tp.is_complete, tp.is_locked, tp.has_report,
       tp.created_at, tp.updated_at,
       COUNT(DISTINCT tr.test_case_id) AS num_test_cases
FROM test_plans tp
LEFT JOIN test_runs tr ON tp.id = tr.test_plan_id
WHERE tp.id = $1
GROUP BY tp.id
`

type GetTestPlanRow struct {
	ID             int64
	ProjectID      int32
	AssignedToID   int32
	CreatedByID    int32
	UpdatedByID    int32
	Kind           TestKind
	Description    sql.NullString
	StartAt        sql.NullTime
	ClosedAt       sql.NullTime
	ScheduledEndAt sql.NullTime
	NumFailures    int32
	IsComplete     sql.NullBool
	IsLocked       sql.NullBool
	HasReport      sql.NullBool
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	NumTestCases   int64
}

func (q *Queries) GetTestPlan(ctx context.Context, id int64) (GetTestPlanRow, error) {
	row := q.db.QueryRowContext(ctx, getTestPlan, id)
	var i GetTestPlanRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.AssignedToID,
		&i.CreatedByID,
		&i.UpdatedByID,
		&i.Kind,
		&i.Description,
		&i.StartAt,
		&i.ClosedAt,
		&i.ScheduledEndAt,
		&i.NumFailures,
		&i.IsComplete,
		&i.IsLocked,
		&i.HasReport,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NumTestCases,
	)
	return i, err
}

const getTestPlanCount = `-- name: GetTestPlanCount :one
SELECT COUNT(*) FROM test_plans
`

func (q *Queries) GetTestPlanCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTestPlanCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTestPlanRunStats = `-- name: GetTestPlanRunStats :one
SELECT
    COUNT(*) FILTER (WHERE result_state = 'passed') AS passed_count,
    COUNT(*) FILTER (WHERE result_state = 'failed') AS failed_count,
    COUNT(*) FILTER (WHERE result_state = 'pending') AS pending_count,
    COUNT(DISTINCT assigned_to_id) AS assigned_testers_count
FROM test_runs
WHERE test_plan_id = $1
`

type GetTestPlanRunStatsRow struct {
	PassedCount          int64
	FailedCount          int64
	PendingCount         int64
	AssignedTestersCount int64
}

func (q *Queries) GetTestPlanRunStats(ctx context.Context, testPlanID int32) (GetTestPlanRunStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTestPlanRunStats, testPlanID)
	var i GetTestPlanRunStatsRow
	err := row.Scan(
		&i.PassedCount,
		&i.FailedCount,
		&i.PendingCount,
		&i.AssignedTestersCount,
	)
	return i, err
}

const getTestPlanStatusRatio = `-- name: GetTestPlanStatusRatio :one
SELECT
COUNT(*) FILTER (WHERE is_complete = true) AS closed,
COUNT(*) FILTER (WHERE is_complete = false) AS open
FROM test_plans
`

type GetTestPlanStatusRatioRow struct {
	Closed int64
	Open   int64
}

func (q *Queries) GetTestPlanStatusRatio(ctx context.Context) (GetTestPlanStatusRatioRow, error) {
	row := q.db.QueryRowContext(ctx, getTestPlanStatusRatio)
	var i GetTestPlanStatusRatioRow
	err := row.Scan(&i.Closed, &i.Open)
	return i, err
}

const getTestRun = `-- name: GetTestRun :one
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE id = $1
`

func (q *Queries) GetTestRun(ctx context.Context, id uuid.UUID) (TestRun, error) {
	row := q.db.QueryRowContext(ctx, getTestRun, id)
	var i TestRun
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.TestPlanID,
		&i.TestCaseID,
		&i.OwnerID,
		&i.TestedByID,
		&i.AssignedToID,
		&i.AssigneeCanChangeCode,
		&i.Code,
		&i.ExternalIssueID,
		&i.ResultState,
		&i.IsClosed,
		&i.Notes,
		&i.ActualResult,
		&i.ExpectedResult,
		&i.Reactions,
		&i.TestedOn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestRunStatesForPlan = `-- name: GetTestRunStatesForPlan :many
SELECT result_state, is_closed FROM test_runs WHERE test_plan_id = $1
`

type GetTestRunStatesForPlanRow struct {
	ResultState TestRunState
	IsClosed    sql.NullBool
}

func (q *Queries) GetTestRunStatesForPlan(ctx context.Context, testPlanID int32) ([]GetTestRunStatesForPlanRow, error) {
	rows, err := q.db.QueryContext(ctx, getTestRunStatesForPlan, testPlanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestRunStatesForPlanRow
	for rows.Next() {
		var i GetTestRunStatesForPlanRow
		if err := rows.Scan(&i.ResultState, &i.IsClosed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTesterByID = `-- name: GetTesterByID :one
SELECT
pt.id, pt.project_id, pt.user_id, pt.role, pt.is_active, pt.created_at, pt.updated_at,
p.title as project,
u.display_name as tester_name,
u.email as tester_email,
u.last_login_at as tester_last_login_at
FROM project_testers pt
INNER JOIN users u ON u.id = pt.user_id
INNER JOIN projects p ON p.id = pt.project_id
WHERE pt.user_id = $1
`

type GetTesterByIDRow struct {
	ID                int32
	ProjectID         int32
	UserID            int32
	Role              string
	IsActive          bool
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	Project           string
	TesterName        sql.NullString
	TesterEmail       string
	TesterLastLoginAt sql.NullTime
}

func (q *Queries) GetTesterByID(ctx context.Context, userID int32) (GetTesterByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTesterByID, userID)
	var i GetTesterByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Project,
		&i.TesterName,
		&i.TesterEmail,
		&i.TesterLastLoginAt,
	)
	return i, err
}

const getTesterCount = `-- name: GetTesterCount :one
SELECT COUNT(DISTINCT user_id) FROM project_testers WHERE is_active = true
`

func (q *Queries) GetTesterCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTesterCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTesterCountByProject = `-- name: GetTesterCountByProject :one
SELECT COUNT(DISTINCT user_id) FROM project_testers WHERE project_id = $1 AND is_active = true
`

func (q *Queries) GetTesterCountByProject(ctx context.Context, projectID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTesterCountByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTestersByProject = `-- name: GetTestersByProject :many
SELECT
project_testers.id, project_testers.project_id, project_testers.user_id, project_testers.role, project_testers.is_active, project_testers.created_at, project_testers.updated_at,
p.title as project,
u.display_name as tester_name,
u.email as tester_email,
u.last_login_at as tester_last_login_at
FROM project_testers
INNER JOIN users u ON u.id = project_testers.user_id
INNER JOIN projects p ON p.id = project_testers.project_id
WHERE project_id = $1
`

type GetTestersByProjectRow struct {
	ID                int32
	ProjectID         int32
	UserID            int32
	Role              string
	IsActive          bool
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	Project           string
	TesterName        sql.NullString
	TesterEmail       string
	TesterLastLoginAt sql.NullTime
}

func (q *Queries) GetTestersByProject(ctx context.Context, projectID int32) ([]GetTestersByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTestersByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestersByProjectRow
	for rows.Next() {
		var i GetTestersByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Project,
			&i.TesterName,
			&i.TesterEmail,
			&i.TesterLastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, first_name, last_name, display_name, email, password, phone, org_id, country_iso, city, address, is_activated, is_reviewed, is_super_admin, is_verified, last_login_at, email_confirmed_at, created_at, updated_at, deleted_at FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.OrgID,
		&i.CountryIso,
		&i.City,
		&i.Address,
		&i.IsActivated,
		&i.IsReviewed,
		&i.IsSuperAdmin,
		&i.IsVerified,
		&i.LastLoginAt,
		&i.EmailConfirmedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const initTestCaseSequence = `-- name: InitTestCaseSequence :exec
INSERT INTO test_case_sequences (project_id, prefix, current_val, last_generated_at)
VALUES ($1, $2, 0, now())
ON CONFLICT (project_id, prefix) DO NOTHING
`

type InitTestCaseSequenceParams struct {
	ProjectID int32
	Prefix    string
}

func (q *Queries) InitTestCaseSequence(ctx context.Context, arg InitTestCaseSequenceParams) error {
	_, err := q.db.ExecContext(ctx, initTestCaseSequence, arg.ProjectID, arg.Prefix)
	return err
}

const insertTestRunResult = `-- name: InsertTestRunResult :one
INSERT INTO test_run_results (
    id, test_run_id, status, result, notes, executed_by, executed_at, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id
`

type InsertTestRunResultParams struct {
	ID         uuid.UUID
	TestRunID  uuid.UUID
	Status     TestRunState
	Result     string
	Notes      sql.NullString
	ExecutedBy int32
	ExecutedAt time.Time
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

func (q *Queries) InsertTestRunResult(ctx context.Context, arg InsertTestRunResultParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertTestRunResult,
		arg.ID,
		arg.TestRunID,
		arg.Status,
		arg.Result,
		arg.Notes,
		arg.ExecutedBy,
		arg.ExecutedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const isTestCaseActive = `-- name: IsTestCaseActive :one
SELECT is_draft FROM test_cases WHERE id = $1
`

func (q *Queries) IsTestCaseActive(ctx context.Context, id uuid.UUID) (sql.NullBool, error) {
	row := q.db.QueryRowContext(ctx, isTestCaseActive, id)
	var is_draft sql.NullBool
	err := row.Scan(&is_draft)
	return is_draft, err
}

const isTestCaseLinkedToProject = `-- name: IsTestCaseLinkedToProject :one
SELECT EXISTS(
    SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE project_id = $1
)
`

func (q *Queries) IsTestCaseLinkedToProject(ctx context.Context, projectID sql.NullInt32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTestCaseLinkedToProject, projectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isTestCaseUsedInTestPlan = `-- name: IsTestCaseUsedInTestPlan :one
SELECT EXISTS(
    SELECT 1 FROM test_runs WHERE test_case_id = $1
)
`

func (q *Queries) IsTestCaseUsedInTestPlan(ctx context.Context, testCaseID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTestCaseUsedInTestPlan, testCaseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isTestCaseUsedInTestRun = `-- name: IsTestCaseUsedInTestRun :one
SELECT EXISTS(
    SELECT 1 FROM test_runs WHERE test_case_id = $1
)
`

func (q *Queries) IsTestCaseUsedInTestRun(ctx context.Context, testCaseID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTestCaseUsedInTestRun, testCaseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isTestPlanActive = `-- name: IsTestPlanActive :one
SELECT closed_at, is_complete
FROM test_plans
WHERE id = $1
`

type IsTestPlanActiveRow struct {
	ClosedAt   sql.NullTime
	IsComplete sql.NullBool
}

func (q *Queries) IsTestPlanActive(ctx context.Context, id int64) (IsTestPlanActiveRow, error) {
	row := q.db.QueryRowContext(ctx, isTestPlanActive, id)
	var i IsTestPlanActiveRow
	err := row.Scan(&i.ClosedAt, &i.IsComplete)
	return i, err
}

const listEnvironmentsByProject = `-- name: ListEnvironmentsByProject :many
SELECT id, project_id, name, description, base_url, created_at, updated_at FROM environments WHERE project_id = $1 ORDER BY name
`

func (q *Queries) ListEnvironmentsByProject(ctx context.Context, projectID sql.NullInt32) ([]Environment, error) {
	rows, err := q.db.QueryContext(ctx, listEnvironmentsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Environment
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.BaseUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, title, description, version, is_active, is_public, website_url, github_url, trello_url, jira_url, monday_url, owner_user_id, created_at, updated_at, deleted_at, code FROM projects ORDER BY created_at DESC
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Version,
			&i.IsActive,
			&i.IsPublic,
			&i.WebsiteUrl,
			&i.GithubUrl,
			&i.TrelloUrl,
			&i.JiraUrl,
			&i.MondayUrl,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCases = `-- name: ListTestCases :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases ORDER BY created_at DESC
`

func (q *Queries) ListTestCases(ctx context.Context) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesByAssignedUser = `-- name: ListTestCasesByAssignedUser :many
SELECT 
tc.id As test_case_id,
tc.kind,
tc.code,
tc.feature_or_module,
tc.title,
tc.description,
tc.parent_test_case_id,
tc.is_draft,
tc.tags,
tc.created_by_id,
tc.created_at AS test_case_created_at,
tc.updated_at AS test_case_updated_at,
tc.project_id,

tr.id AS test_run_id,
tr.test_plan_id,
tr.owner_id,
tr.tested_by_id,
tr.assigned_to_id,
tr.assignee_can_change_code,
tr.external_issue_id,
tr.result_state,
tr.is_closed,
tr.notes,
tr.actual_result,
tr.expected_result,
tr.reactions,
tr.tested_on,
tr.created_at AS run_created_at,
tr.updated_at AS run_updated_at
FROM test_runs tr
INNER JOIN test_cases tc ON tc.id = tr.test_case_id
WHERE tr.assigned_to_id = $1
ORDER BY tr.created_at DESC
LIMIT $2 OFFSET $3
`

type ListTestCasesByAssignedUserParams struct {
	AssignedToID int32
	Limit        int32
	Offset       int32
}

type ListTestCasesByAssignedUserRow struct {
	TestCaseID            uuid.UUID
	Kind                  TestKind
	Code                  string
	FeatureOrModule       sql.NullString
	Title                 string
	Description           string
	ParentTestCaseID      sql.NullInt32
	IsDraft               sql.NullBool
	Tags                  []string
	CreatedByID           int32
	TestCaseCreatedAt     sql.NullTime
	TestCaseUpdatedAt     sql.NullTime
	ProjectID             sql.NullInt32
	TestRunID             uuid.UUID
	TestPlanID            int32
	OwnerID               int32
	TestedByID            int32
	AssignedToID          int32
	AssigneeCanChangeCode sql.NullBool
	ExternalIssueID       sql.NullString
	ResultState           TestRunState
	IsClosed              sql.NullBool
	Notes                 string
	ActualResult          sql.NullString
	ExpectedResult        sql.NullString
	Reactions             pqtype.NullRawMessage
	TestedOn              time.Time
	RunCreatedAt          sql.NullTime
	RunUpdatedAt          sql.NullTime
}

func (q *Queries) ListTestCasesByAssignedUser(ctx context.Context, arg ListTestCasesByAssignedUserParams) ([]ListTestCasesByAssignedUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listTestCasesByAssignedUser, arg.AssignedToID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestCasesByAssignedUserRow
	for rows.Next() {
		var i ListTestCasesByAssignedUserRow
		if err := rows.Scan(
			&i.TestCaseID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.TestCaseCreatedAt,
			&i.TestCaseUpdatedAt,
			&i.ProjectID,
			&i.TestRunID,
			&i.TestPlanID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.RunCreatedAt,
			&i.RunUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesByCreator = `-- name: ListTestCasesByCreator :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE created_by_id = $1
`

func (q *Queries) ListTestCasesByCreator(ctx context.Context, createdByID int32) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCasesByCreator, createdByID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesByPlan = `-- name: ListTestCasesByPlan :many
SELECT DISTINCT tc.id, tc.kind, tc.code, tc.feature_or_module, tc.title, tc.description, tc.parent_test_case_id, tc.is_draft, tc.tags, tc.created_by_id, tc.created_at, tc.updated_at, tc.project_id
FROM test_cases tc
INNER JOIN test_runs tr ON tr.test_case_id = tc.id
WHERE tr.test_plan_id = $1::bigint
`

func (q *Queries) ListTestCasesByPlan(ctx context.Context, dollar_1 int64) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCasesByPlan, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesByProject = `-- name: ListTestCasesByProject :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE project_id = $1
`

func (q *Queries) ListTestCasesByProject(ctx context.Context, projectID sql.NullInt32) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCasesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestPlans = `-- name: ListTestPlans :many
SELECT id, project_id, assigned_to_id, created_by_id, updated_by_id, kind, description, start_at, closed_at, scheduled_end_at, num_test_cases, num_failures, is_complete, is_locked, has_report, created_at, updated_at, environment_id FROM test_plans ORDER BY created_at DESC
`

func (q *Queries) ListTestPlans(ctx context.Context) ([]TestPlan, error) {
	rows, err := q.db.QueryContext(ctx, listTestPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestPlan
	for rows.Next() {
		var i TestPlan
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.AssignedToID,
			&i.CreatedByID,
			&i.UpdatedByID,
			&i.Kind,
			&i.Description,
			&i.StartAt,
			&i.ClosedAt,
			&i.ScheduledEndAt,
			&i.NumTestCases,
			&i.NumFailures,
			&i.IsComplete,
			&i.IsLocked,
			&i.HasReport,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EnvironmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestPlansByProject = `-- name: ListTestPlansByProject :many
SELECT id, project_id, assigned_to_id, created_by_id, updated_by_id, kind, description, start_at, closed_at, scheduled_end_at, num_test_cases, num_failures, is_complete, is_locked, has_report, created_at, updated_at, environment_id FROM test_plans WHERE project_id = $1
`

func (q *Queries) ListTestPlansByProject(ctx context.Context, projectID int32) ([]TestPlan, error) {
	rows, err := q.db.QueryContext(ctx, listTestPlansByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestPlan
	for rows.Next() {
		var i TestPlan
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.AssignedToID,
			&i.CreatedByID,
			&i.UpdatedByID,
			&i.Kind,
			&i.Description,
			&i.StartAt,
			&i.ClosedAt,
			&i.ScheduledEndAt,
			&i.NumTestCases,
			&i.NumFailures,
			&i.IsComplete,
			&i.IsLocked,
			&i.HasReport,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EnvironmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRuns = `-- name: ListTestRuns :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs ORDER BY created_at DESC
`

func (q *Queries) ListTestRuns(ctx context.Context) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsAssignedToUser = `-- name: ListTestRunsAssignedToUser :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE assigned_to_id = $1
`

func (q *Queries) ListTestRunsAssignedToUser(ctx context.Context, assignedToID int32) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsAssignedToUser, assignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsByOwner = `-- name: ListTestRunsByOwner :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE owner_id = $1
`

func (q *Queries) ListTestRunsByOwner(ctx context.Context, ownerID int32) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsByPlan = `-- name: ListTestRunsByPlan :many
SELECT
    tr.id,
    tr.project_id,
    tr.test_plan_id,
    tr.test_case_id,
    tr.owner_id,
    tr.tested_by_id,
    tr.assigned_to_id,
    tr.code,
    tr.result_state,
    tr.is_closed,
    tr.notes,
    tr.actual_result,
    tr.expected_result,
    tr.tested_on,
    tr.created_at,
    tr.updated_at,
    tc.title AS test_case_title,
    u.display_name AS executed_by
FROM test_runs tr
JOIN test_cases tc ON tr.test_case_id = tc.id
JOIN users u ON tr.tested_by_id = u.id
WHERE tr.test_plan_id = $1
ORDER BY tr.created_at DESC
`

type ListTestRunsByPlanRow struct {
	ID             uuid.UUID
	ProjectID      int32
	TestPlanID     int32
	TestCaseID     uuid.UUID
	OwnerID        int32
	TestedByID     int32
	AssignedToID   int32
	Code           string
	ResultState    TestRunState
	IsClosed       sql.NullBool
	Notes          string
	ActualResult   sql.NullString
	ExpectedResult sql.NullString
	TestedOn       time.Time
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	TestCaseTitle  string
	ExecutedBy     sql.NullString
}

func (q *Queries) ListTestRunsByPlan(ctx context.Context, testPlanID int32) ([]ListTestRunsByPlanRow, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsByPlan, testPlanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestRunsByPlanRow
	for rows.Next() {
		var i ListTestRunsByPlanRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.Code,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TestCaseTitle,
			&i.ExecutedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsByProject = `-- name: ListTestRunsByProject :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE project_id = $1
`

func (q *Queries) ListTestRunsByProject(ctx context.Context, projectID int32) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, first_name, last_name, display_name, email, password, phone, org_id, country_iso, city, address, is_activated, is_reviewed, is_super_admin, is_verified, last_login_at, email_confirmed_at, created_at, updated_at, deleted_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.Email,
			&i.Password,
			&i.Phone,
			&i.OrgID,
			&i.CountryIso,
			&i.City,
			&i.Address,
			&i.IsActivated,
			&i.IsReviewed,
			&i.IsSuperAdmin,
			&i.IsVerified,
			&i.LastLoginAt,
			&i.EmailConfirmedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProject = `-- name: SearchProject :many
SELECT id, title, description, version, is_active, is_public, website_url, github_url, trello_url, jira_url, monday_url, owner_user_id, created_at, updated_at, deleted_at, code FROM projects
WHERE title ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchProject(ctx context.Context, dollar_1 sql.NullString) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, searchProject, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Version,
			&i.IsActive,
			&i.IsPublic,
			&i.WebsiteUrl,
			&i.GithubUrl,
			&i.TrelloUrl,
			&i.JiraUrl,
			&i.MondayUrl,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectTesters = `-- name: SearchProjectTesters :many
SELECT
project_testers.id, project_testers.project_id, project_testers.user_id, project_testers.role, project_testers.is_active, project_testers.created_at, project_testers.updated_at,
u.display_name AS tester_name
FROM project_testers
INNER JOIN users u On u.id = project_testers.user_id
WHERE project_testers.role ILIKE '%' || $1 || '%'
`

type SearchProjectTestersRow struct {
	ID         int32
	ProjectID  int32
	UserID     int32
	Role       string
	IsActive   bool
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
	TesterName sql.NullString
}

func (q *Queries) SearchProjectTesters(ctx context.Context, dollar_1 sql.NullString) ([]SearchProjectTestersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProjectTesters, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProjectTestersRow
	for rows.Next() {
		var i SearchProjectTestersRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TesterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTestCases = `-- name: SearchTestCases :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases
WHERE title ILIKE '%' || $1 || '%'
OR code ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchTestCases(ctx context.Context, dollar_1 sql.NullString) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, searchTestCases, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, first_name, last_name, display_name, email, password, phone, org_id, country_iso, city, address, is_activated, is_reviewed, is_super_admin, is_verified, last_login_at, email_confirmed_at, created_at, updated_at, deleted_at FROM users
WHERE first_name ILIKE '%' || $1 || '%'
OR last_name ILIKE '%' || $1 || '%'
OR display_name ILIKE '%' || $1 || '%'
OR email ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchUsers(ctx context.Context, dollar_1 sql.NullString) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.Email,
			&i.Password,
			&i.Phone,
			&i.OrgID,
			&i.CountryIso,
			&i.City,
			&i.Address,
			&i.IsActivated,
			&i.IsReviewed,
			&i.IsSuperAdmin,
			&i.IsVerified,
			&i.LastLoginAt,
			&i.EmailConfirmedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTestCaseDraftStatus = `-- name: SetTestCaseDraftStatus :exec
UPDATE test_cases
SET is_draft = $2, updated_at = NOW()
WHERE id = $1
`

type SetTestCaseDraftStatusParams struct {
	ID      uuid.UUID
	IsDraft sql.NullBool
}

func (q *Queries) SetTestCaseDraftStatus(ctx context.Context, arg SetTestCaseDraftStatusParams) error {
	_, err := q.db.ExecContext(ctx, setTestCaseDraftStatus, arg.ID, arg.IsDraft)
	return err
}

const updatePage = `-- name: UpdatePage :exec
UPDATE pages SET parent_page_id = $2, page_version = $3, org_id = $4, project_id = $5, code = $6, title = $7, file_path = $8, content = $9, page_type = $10, mime_type = $11, has_embedded_media = $12, external_content_url = $13, notion_url = $14, last_edited_by = $15, created_by = $16
WHERE id = $1
`

type UpdatePageParams struct {
	ID                 int32
	ParentPageID       sql.NullInt32
	PageVersion        string
	OrgID              int32
	ProjectID          int32
	Code               string
	Title              string
	FilePath           sql.NullString
	Content            string
	PageType           string
	MimeType           string
	HasEmbeddedMedia   bool
	ExternalContentUrl sql.NullString
	NotionUrl          sql.NullString
	LastEditedBy       int32
	CreatedBy          int32
}

func (q *Queries) UpdatePage(ctx context.Context, arg UpdatePageParams) error {
	_, err := q.db.ExecContext(ctx, updatePage,
		arg.ID,
		arg.ParentPageID,
		arg.PageVersion,
		arg.OrgID,
		arg.ProjectID,
		arg.Code,
		arg.Title,
		arg.FilePath,
		arg.Content,
		arg.PageType,
		arg.MimeType,
		arg.HasEmbeddedMedia,
		arg.ExternalContentUrl,
		arg.NotionUrl,
		arg.LastEditedBy,
		arg.CreatedBy,
	)
	return err
}

const updateProject = `-- name: UpdateProject :execrows
UPDATE projects SET
title = $2, description = $3, website_url = $4,
version = $5, github_url = $6,
owner_user_id = $7
WHERE id = $1
`

type UpdateProjectParams struct {
	ID          int32
	Title       string
	Description string
	WebsiteUrl  sql.NullString
	Version     sql.NullString
	GithubUrl   sql.NullString
	OwnerUserID int32
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProject,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.WebsiteUrl,
		arg.Version,
		arg.GithubUrl,
		arg.OwnerUserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProjectModule = `-- name: UpdateProjectModule :exec
UPDATE modules SET name = $2, code = $3, priority = $4, type = $5, description = $6
WHERE id = $1
`

type UpdateProjectModuleParams struct {
	ID          int32
	Name        string
	Code        string
	Priority    int32
	Type        string
	Description string
}

func (q *Queries) UpdateProjectModule(ctx context.Context, arg UpdateProjectModuleParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectModule,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.Priority,
		arg.Type,
		arg.Description,
	)
	return err
}

const updateProjectTesterRole = `-- name: UpdateProjectTesterRole :execrows
UPDATE project_testers SET role = $2 WHERE user_id = $1
`

type UpdateProjectTesterRoleParams struct {
	UserID int32
	Role   string
}

func (q *Queries) UpdateProjectTesterRole(ctx context.Context, arg UpdateProjectTesterRoleParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProjectTesterRole, arg.UserID, arg.Role)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTestCase = `-- name: UpdateTestCase :exec
UPDATE test_cases SET
kind = $2,
code = $3,
feature_or_module = $4,
title = $5,
description = $6,
is_draft = $7,
tags = $8,
updated_at = $9
WHERE id = $1
`

type UpdateTestCaseParams struct {
	ID              uuid.UUID
	Kind            TestKind
	Code            string
	FeatureOrModule sql.NullString
	Title           string
	Description     string
	IsDraft         sql.NullBool
	Tags            []string
	UpdatedAt       sql.NullTime
}

func (q *Queries) UpdateTestCase(ctx context.Context, arg UpdateTestCaseParams) error {
	_, err := q.db.ExecContext(ctx, updateTestCase,
		arg.ID,
		arg.Kind,
		arg.Code,
		arg.FeatureOrModule,
		arg.Title,
		arg.Description,
		arg.IsDraft,
		pq.Array(arg.Tags),
		arg.UpdatedAt,
	)
	return err
}

const updateTestPlan = `-- name: UpdateTestPlan :exec
UPDATE test_plans SET project_id = $2, assigned_to_id = $3, created_by_id = $4,
updated_by_id = $5, kind = $6, description = $7, start_at = $8,
closed_at = $9, scheduled_end_at = $10, num_test_cases = $11,
num_failures = $12, is_complete = $13, is_locked = $14,
has_report = $15, created_at = $16, updated_at = $17
WHERE id = $1
`

type UpdateTestPlanParams struct {
	ID             int64
	ProjectID      int32
	AssignedToID   int32
	CreatedByID    int32
	UpdatedByID    int32
	Kind           TestKind
	Description    sql.NullString
	StartAt        sql.NullTime
	ClosedAt       sql.NullTime
	ScheduledEndAt sql.NullTime
	NumTestCases   int32
	NumFailures    int32
	IsComplete     sql.NullBool
	IsLocked       sql.NullBool
	HasReport      sql.NullBool
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
}

func (q *Queries) UpdateTestPlan(ctx context.Context, arg UpdateTestPlanParams) error {
	_, err := q.db.ExecContext(ctx, updateTestPlan,
		arg.ID,
		arg.ProjectID,
		arg.AssignedToID,
		arg.CreatedByID,
		arg.UpdatedByID,
		arg.Kind,
		arg.Description,
		arg.StartAt,
		arg.ClosedAt,
		arg.ScheduledEndAt,
		arg.NumTestCases,
		arg.NumFailures,
		arg.IsComplete,
		arg.IsLocked,
		arg.HasReport,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET
    first_name = $2, last_name = $3, display_name = $4, phone = $5,
    org_id = $6, country_iso = $7, city = $8, address = $9,
    is_activated = $10, is_reviewed = $11, is_super_admin = $12, is_verified = $13,
    last_login_at = $14, email_confirmed_at = $15, created_at = $16, updated_at = $17, deleted_at = $18
WHERE id = $1
`

type UpdateUserParams struct {
	ID               int32
	FirstName        string
	LastName         string
	DisplayName      sql.NullString
	Phone            string
	OrgID            sql.NullInt32
	CountryIso       string
	City             sql.NullString
	Address          string
	IsActivated      sql.NullBool
	IsReviewed       sql.NullBool
	IsSuperAdmin     sql.NullBool
	IsVerified       sql.NullBool
	LastLoginAt      sql.NullTime
	EmailConfirmedAt sql.NullTime
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	DeletedAt        sql.NullTime
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.DisplayName,
		arg.Phone,
		arg.OrgID,
		arg.CountryIso,
		arg.City,
		arg.Address,
		arg.IsActivated,
		arg.IsReviewed,
		arg.IsSuperAdmin,
		arg.IsVerified,
		arg.LastLoginAt,
		arg.EmailConfirmedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :execrows
UPDATE users SET last_login_at = $1 WHERE id = $2 AND is_activated AND deleted_at IS NULL
`

type UpdateUserLastLoginParams struct {
	LastLoginAt sql.NullTime
	ID          int32
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateUserLastLogin, arg.LastLoginAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const userExists = `-- name: UserExists :one
SELECT EXISTS(SELECT id FROM users WHERE id = $1)
`

func (q *Queries) UserExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
