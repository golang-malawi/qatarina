// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package dbsqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const assignTesterToProject = `-- name: AssignTesterToProject :execrows
INSERT INTO project_testers (
    project_id, user_id, role, is_active, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, now(), now()
)
`

type AssignTesterToProjectParams struct {
	ProjectID int32
	UserID    int32
	Role      string
	IsActive  bool
}

func (q *Queries) AssignTesterToProject(ctx context.Context, arg AssignTesterToProjectParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, assignTesterToProject,
		arg.ProjectID,
		arg.UserID,
		arg.Role,
		arg.IsActive,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const commitTestRunResult = `-- name: CommitTestRunResult :one
UPDATE test_runs SET
    tested_by_id = $2,
    updated_at = $3,
    result_state = $4,
    is_closed = $5,
    notes = $6,
    tested_on = $7,
    actual_result = $8,
    expected_result = $9
WHERE id = $1
RETURNING id
`

type CommitTestRunResultParams struct {
	ID             uuid.UUID
	TestedByID     int32
	UpdatedAt      sql.NullTime
	ResultState    TestRunState
	IsClosed       sql.NullBool
	Notes          string
	TestedOn       time.Time
	ActualResult   sql.NullString
	ExpectedResult sql.NullString
}

func (q *Queries) CommitTestRunResult(ctx context.Context, arg CommitTestRunResultParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, commitTestRunResult,
		arg.ID,
		arg.TestedByID,
		arg.UpdatedAt,
		arg.ResultState,
		arg.IsClosed,
		arg.Notes,
		arg.TestedOn,
		arg.ActualResult,
		arg.ExpectedResult,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const countTestCasesNotLinkedToProject = `-- name: CountTestCasesNotLinkedToProject :one
SELECT COUNT(*) FROM test_cases
RIGHT OUTER JOIN test_plans p ON p.test_case_id = test_cases.id
WHERE p.project_id IS NULL
`

func (q *Queries) CountTestCasesNotLinkedToProject(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTestCasesNotLinkedToProject)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvite = `-- name: CreateInvite :exec
INSERT INTO invites (sender_email, receiver_email, token, expires_at)
VALUES ($1, $2, $3, $4)
`

type CreateInviteParams struct {
	SenderEmail   string
	ReceiverEmail string
	Token         string
	ExpiresAt     sql.NullTime
}

func (q *Queries) CreateInvite(ctx context.Context, arg CreateInviteParams) error {
	_, err := q.db.ExecContext(ctx, createInvite,
		arg.SenderEmail,
		arg.ReceiverEmail,
		arg.Token,
		arg.ExpiresAt,
	)
	return err
}

const createNewTestRun = `-- name: CreateNewTestRun :one
INSERT INTO test_runs (
id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, code, created_at, updated_at,
result_state, is_closed, assignee_can_change_code, notes,reactions, tested_on, expected_result
)
VALUES (
$1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
'pending', false, false, 'None', '{}'::jsonb, now(), 'Test to Pass'
)
RETURNING id
`

type CreateNewTestRunParams struct {
	ID           uuid.UUID
	ProjectID    int32
	TestPlanID   int32
	TestCaseID   uuid.UUID
	OwnerID      int32
	TestedByID   int32
	AssignedToID int32
	Code         string
	CreatedAt    sql.NullTime
	UpdatedAt    sql.NullTime
}

func (q *Queries) CreateNewTestRun(ctx context.Context, arg CreateNewTestRunParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createNewTestRun,
		arg.ID,
		arg.ProjectID,
		arg.TestPlanID,
		arg.TestCaseID,
		arg.OwnerID,
		arg.TestedByID,
		arg.AssignedToID,
		arg.Code,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createPage = `-- name: CreatePage :one
INSERT INTO pages(parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at
) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, now(), now(), now()) RETURNING id, parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at
`

type CreatePageParams struct {
	ParentPageID       sql.NullInt32
	PageVersion        string
	OrgID              int32
	ProjectID          int32
	Code               string
	Title              string
	FilePath           sql.NullString
	Content            string
	PageType           string
	MimeType           string
	HasEmbeddedMedia   bool
	ExternalContentUrl sql.NullString
	NotionUrl          sql.NullString
	LastEditedBy       int32
	CreatedBy          int32
}

func (q *Queries) CreatePage(ctx context.Context, arg CreatePageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, createPage,
		arg.ParentPageID,
		arg.PageVersion,
		arg.OrgID,
		arg.ProjectID,
		arg.Code,
		arg.Title,
		arg.FilePath,
		arg.Content,
		arg.PageType,
		arg.MimeType,
		arg.HasEmbeddedMedia,
		arg.ExternalContentUrl,
		arg.NotionUrl,
		arg.LastEditedBy,
		arg.CreatedBy,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.ParentPageID,
		&i.PageVersion,
		&i.OrgID,
		&i.ProjectID,
		&i.Code,
		&i.Title,
		&i.FilePath,
		&i.Content,
		&i.PageType,
		&i.MimeType,
		&i.HasEmbeddedMedia,
		&i.ExternalContentUrl,
		&i.NotionUrl,
		&i.LastEditedBy,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    title, description, version, is_active, is_public, website_url,
    github_url, trello_url, jira_url, monday_url,
    owner_user_id, created_at, updated_at, deleted_at
)
VALUES(
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13, $14
) RETURNING id
`

type CreateProjectParams struct {
	Title       string
	Description string
	Version     sql.NullString
	IsActive    sql.NullBool
	IsPublic    sql.NullBool
	WebsiteUrl  sql.NullString
	GithubUrl   sql.NullString
	TrelloUrl   sql.NullString
	JiraUrl     sql.NullString
	MondayUrl   sql.NullString
	OwnerUserID int32
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Title,
		arg.Description,
		arg.Version,
		arg.IsActive,
		arg.IsPublic,
		arg.WebsiteUrl,
		arg.GithubUrl,
		arg.TrelloUrl,
		arg.JiraUrl,
		arg.MondayUrl,
		arg.OwnerUserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createProjectModules = `-- name: CreateProjectModules :one
INSERT INTO modules(
    project_id, name, code, priority, type, description, created_at, updated_at
)VALUES($1, $2, $3, $4, $5, $6, now(), now()
)
RETURNING id, project_id, name, code, priority, type, description, created_at, updated_at
`

type CreateProjectModulesParams struct {
	ProjectID   int32
	Name        string
	Code        string
	Priority    int32
	Type        string
	Description string
}

func (q *Queries) CreateProjectModules(ctx context.Context, arg CreateProjectModulesParams) (Module, error) {
	row := q.db.QueryRowContext(ctx, createProjectModules,
		arg.ProjectID,
		arg.Name,
		arg.Code,
		arg.Priority,
		arg.Type,
		arg.Description,
	)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Code,
		&i.Priority,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTestCase = `-- name: CreateTestCase :one
INSERT INTO test_cases (
    id, kind, code, feature_or_module, title, description, parent_test_case_id,
    is_draft, tags, created_by_id, created_at, updated_at, project_id
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13
)
RETURNING id
`

type CreateTestCaseParams struct {
	ID               uuid.UUID
	Kind             TestKind
	Code             string
	FeatureOrModule  sql.NullString
	Title            string
	Description      string
	ParentTestCaseID sql.NullInt32
	IsDraft          sql.NullBool
	Tags             []string
	CreatedByID      int32
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ProjectID        sql.NullInt32
}

func (q *Queries) CreateTestCase(ctx context.Context, arg CreateTestCaseParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createTestCase,
		arg.ID,
		arg.Kind,
		arg.Code,
		arg.FeatureOrModule,
		arg.Title,
		arg.Description,
		arg.ParentTestCaseID,
		arg.IsDraft,
		pq.Array(arg.Tags),
		arg.CreatedByID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProjectID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createTestPlan = `-- name: CreateTestPlan :one
INSERT INTO test_plans (
    project_id, assigned_to_id, created_by_id, updated_by_id,
    kind, description, start_at, closed_at, scheduled_end_at,
    num_test_cases, num_failures, is_complete, is_locked, has_report,
    created_at, updated_at
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $7, $8,
    $9, $10, $11, $12, $13, $14, $15
)
RETURNING id
`

type CreateTestPlanParams struct {
	ProjectID      int32
	AssignedToID   int32
	CreatedByID    int32
	UpdatedByID    int32
	Kind           TestKind
	Description    sql.NullString
	StartAt        sql.NullTime
	ScheduledEndAt sql.NullTime
	NumTestCases   int32
	NumFailures    int32
	IsComplete     sql.NullBool
	IsLocked       sql.NullBool
	HasReport      sql.NullBool
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
}

func (q *Queries) CreateTestPlan(ctx context.Context, arg CreateTestPlanParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createTestPlan,
		arg.ProjectID,
		arg.AssignedToID,
		arg.CreatedByID,
		arg.UpdatedByID,
		arg.Kind,
		arg.Description,
		arg.StartAt,
		arg.ScheduledEndAt,
		arg.NumTestCases,
		arg.NumFailures,
		arg.IsComplete,
		arg.IsLocked,
		arg.HasReport,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    first_name, last_name, display_name, email, password, phone,
    org_id, country_iso, city, address,
    is_activated, is_reviewed, is_super_admin, is_verified,
    last_login_at, email_confirmed_at, created_at, updated_at, deleted_at
)
VALUES(
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17, $18, $19
)
RETURNING id
`

type CreateUserParams struct {
	FirstName        string
	LastName         string
	DisplayName      sql.NullString
	Email            string
	Password         string
	Phone            string
	OrgID            sql.NullInt32
	CountryIso       string
	City             sql.NullString
	Address          string
	IsActivated      sql.NullBool
	IsReviewed       sql.NullBool
	IsSuperAdmin     sql.NullBool
	IsVerified       sql.NullBool
	LastLoginAt      sql.NullTime
	EmailConfirmedAt sql.NullTime
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	DeletedAt        sql.NullTime
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.DisplayName,
		arg.Email,
		arg.Password,
		arg.Phone,
		arg.OrgID,
		arg.CountryIso,
		arg.City,
		arg.Address,
		arg.IsActivated,
		arg.IsReviewed,
		arg.IsSuperAdmin,
		arg.IsVerified,
		arg.LastLoginAt,
		arg.EmailConfirmedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAllTestPlansInProject = `-- name: DeleteAllTestPlansInProject :execrows
DELETE FROM test_plans WHERE project_id = $1
`

func (q *Queries) DeleteAllTestPlansInProject(ctx context.Context, projectID int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAllTestPlansInProject, projectID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteAllTestRunsInProject = `-- name: DeleteAllTestRunsInProject :execrows
DELETE FROM test_runs WHERE project_id = $1
`

func (q *Queries) DeleteAllTestRunsInProject(ctx context.Context, projectID int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteAllTestRunsInProject, projectID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deletePage = `-- name: DeletePage :execrows
DELETE FROM pages WHERE id = $1
`

func (q *Queries) DeletePage(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePage, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProject = `-- name: DeleteProject :execrows
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProject, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProjectModule = `-- name: DeleteProjectModule :execrows
DELETE FROM modules WHERE id = $1
`

func (q *Queries) DeleteProjectModule(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProjectModule, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProjectTester = `-- name: DeleteProjectTester :execrows
DELETE FROM project_testers WHERE id = $1
`

func (q *Queries) DeleteProjectTester(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProjectTester, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTestCase = `-- name: DeleteTestCase :execrows
DELETE FROM test_cases WHERE id = $1
`

func (q *Queries) DeleteTestCase(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTestCase, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTestPlan = `-- name: DeleteTestPlan :execrows
DELETE FROM test_plans WHERE id = $1
`

func (q *Queries) DeleteTestPlan(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTestPlan, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTestRun = `-- name: DeleteTestRun :execrows
DELETE FROM test_runs WHERE id = $1
`

func (q *Queries) DeleteTestRun(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTestRun, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteUser = `-- name: DeleteUser :execrows
DELETE FROM users WHERE id=$1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const findUserLoginByEmail = `-- name: FindUserLoginByEmail :one
SELECT id, display_name, email, password, last_login_at FROM users WHERE email = $1 AND is_activated AND deleted_at IS NULL
`

type FindUserLoginByEmailRow struct {
	ID          int32
	DisplayName sql.NullString
	Email       string
	Password    string
	LastLoginAt sql.NullTime
}

func (q *Queries) FindUserLoginByEmail(ctx context.Context, email string) (FindUserLoginByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, findUserLoginByEmail, email)
	var i FindUserLoginByEmailRow
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Email,
		&i.Password,
		&i.LastLoginAt,
	)
	return i, err
}

const getAllModules = `-- name: GetAllModules :many
SELECT id, project_id, name, code, priority, type, description, created_at, updated_at FROM modules
ORDER BY created_at DESC
`

func (q *Queries) GetAllModules(ctx context.Context) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, getAllModules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Code,
			&i.Priority,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPages = `-- name: GetAllPages :many
SELECT id, parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at FROM pages
ORDER BY created_at DESC
`

func (q *Queries) GetAllPages(ctx context.Context) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, getAllPages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.ParentPageID,
			&i.PageVersion,
			&i.OrgID,
			&i.ProjectID,
			&i.Code,
			&i.Title,
			&i.FilePath,
			&i.Content,
			&i.PageType,
			&i.MimeType,
			&i.HasEmbeddedMedia,
			&i.ExternalContentUrl,
			&i.NotionUrl,
			&i.LastEditedBy,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCodeByPrefix = `-- name: GetLatestCodeByPrefix :one
SELECT code FROM test_cases
WHERE code LIKE $1 || '%'
ORDER BY code DESC
LIMIT 1
FOR UPDATE
`

func (q *Queries) GetLatestCodeByPrefix(ctx context.Context, dollar_1 sql.NullString) (string, error) {
	row := q.db.QueryRowContext(ctx, getLatestCodeByPrefix, dollar_1)
	var code string
	err := row.Scan(&code)
	return code, err
}

const getNextTestCaseSequence = `-- name: GetNextTestCaseSequence :one
UPDATE test_case_sequences
SET current_val = current_val +1,
last_generated_at = now()
WHERE project_id = $1 AND prefix = $2
RETURNING current_val
`

type GetNextTestCaseSequenceParams struct {
	ProjectID int32
	Prefix    string
}

func (q *Queries) GetNextTestCaseSequence(ctx context.Context, arg GetNextTestCaseSequenceParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextTestCaseSequence, arg.ProjectID, arg.Prefix)
	var current_val int32
	err := row.Scan(&current_val)
	return current_val, err
}

const getOneModule = `-- name: GetOneModule :one
SELECT id, project_id, name, code, priority, type, description, created_at, updated_at FROM modules
WHERE id = $1
`

func (q *Queries) GetOneModule(ctx context.Context, id int32) (Module, error) {
	row := q.db.QueryRowContext(ctx, getOneModule, id)
	var i Module
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Code,
		&i.Priority,
		&i.Type,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPage = `-- name: GetPage :one
SELECT id, parent_page_id, page_version, org_id, project_id, code, title, file_path, content, page_type, mime_type, has_embedded_media, external_content_url, notion_url, last_edited_by, created_by, created_at, updated_at, deleted_at FROM pages WHERE id = $1
`

func (q *Queries) GetPage(ctx context.Context, id int32) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPage, id)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.ParentPageID,
		&i.PageVersion,
		&i.OrgID,
		&i.ProjectID,
		&i.Code,
		&i.Title,
		&i.FilePath,
		&i.Content,
		&i.PageType,
		&i.MimeType,
		&i.HasEmbeddedMedia,
		&i.ExternalContentUrl,
		&i.NotionUrl,
		&i.LastEditedBy,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProject = `-- name: GetProject :one
SELECT id, title, description, version, is_active, is_public, website_url, github_url, trello_url, jira_url, monday_url, owner_user_id, created_at, updated_at, deleted_at, code FROM projects WHERE id = $1
`

func (q *Queries) GetProject(ctx context.Context, id int32) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Version,
		&i.IsActive,
		&i.IsPublic,
		&i.WebsiteUrl,
		&i.GithubUrl,
		&i.TrelloUrl,
		&i.JiraUrl,
		&i.MondayUrl,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Code,
	)
	return i, err
}

const getProjectCount = `-- name: GetProjectCount :one
SELECT COUNT(*) FROM projects
`

func (q *Queries) GetProjectCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProjectCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectModules = `-- name: GetProjectModules :many
SELECT id, project_id, name, code, priority, type, description, created_at, updated_at FROM modules
WHERE project_id = $1
`

func (q *Queries) GetProjectModules(ctx context.Context, projectID int32) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, getProjectModules, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Code,
			&i.Priority,
			&i.Type,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentProjects = `-- name: GetRecentProjects :many
SELECT id, title AS name, updated_at
FROM projects
ORDER BY updated_at DESC
LIMIT 5
`

type GetRecentProjectsRow struct {
	ID        int32
	Name      string
	UpdatedAt time.Time
}

func (q *Queries) GetRecentProjects(ctx context.Context) ([]GetRecentProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentProjectsRow
	for rows.Next() {
		var i GetRecentProjectsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCase = `-- name: GetTestCase :one
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE id = $1
`

func (q *Queries) GetTestCase(ctx context.Context, id uuid.UUID) (TestCase, error) {
	row := q.db.QueryRowContext(ctx, getTestCase, id)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Code,
		&i.FeatureOrModule,
		&i.Title,
		&i.Description,
		&i.ParentTestCaseID,
		&i.IsDraft,
		pq.Array(&i.Tags),
		&i.CreatedByID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
	)
	return i, err
}

const getTestCaseByCode = `-- name: GetTestCaseByCode :one
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases 
WHERE project_id = $1 AND code = $2
`

type GetTestCaseByCodeParams struct {
	ProjectID sql.NullInt32
	Code      string
}

func (q *Queries) GetTestCaseByCode(ctx context.Context, arg GetTestCaseByCodeParams) (TestCase, error) {
	row := q.db.QueryRowContext(ctx, getTestCaseByCode, arg.ProjectID, arg.Code)
	var i TestCase
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Code,
		&i.FeatureOrModule,
		&i.Title,
		&i.Description,
		&i.ParentTestCaseID,
		&i.IsDraft,
		pq.Array(&i.Tags),
		&i.CreatedByID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectID,
	)
	return i, err
}

const getTestCaseCount = `-- name: GetTestCaseCount :one
SELECT COUNT(*) FROM test_cases
`

func (q *Queries) GetTestCaseCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTestCaseCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTestPlan = `-- name: GetTestPlan :one
SELECT id, project_id, assigned_to_id, created_by_id, updated_by_id, kind, description, start_at, closed_at, scheduled_end_at, num_test_cases, num_failures, is_complete, is_locked, has_report, created_at, updated_at FROM test_plans WHERE id = $1
`

func (q *Queries) GetTestPlan(ctx context.Context, id int64) (TestPlan, error) {
	row := q.db.QueryRowContext(ctx, getTestPlan, id)
	var i TestPlan
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.AssignedToID,
		&i.CreatedByID,
		&i.UpdatedByID,
		&i.Kind,
		&i.Description,
		&i.StartAt,
		&i.ClosedAt,
		&i.ScheduledEndAt,
		&i.NumTestCases,
		&i.NumFailures,
		&i.IsComplete,
		&i.IsLocked,
		&i.HasReport,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestPlanCount = `-- name: GetTestPlanCount :one
SELECT COUNT(*) FROM test_plans
`

func (q *Queries) GetTestPlanCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTestPlanCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTestPlanStatusRatio = `-- name: GetTestPlanStatusRatio :one
SELECT
COUNT(*) FILTER (WHERE is_complete = true) AS closed,
COUNT(*) FILTER (WHERE is_complete = false) AS open
FROM test_plans
`

type GetTestPlanStatusRatioRow struct {
	Closed int64
	Open   int64
}

func (q *Queries) GetTestPlanStatusRatio(ctx context.Context) (GetTestPlanStatusRatioRow, error) {
	row := q.db.QueryRowContext(ctx, getTestPlanStatusRatio)
	var i GetTestPlanStatusRatioRow
	err := row.Scan(&i.Closed, &i.Open)
	return i, err
}

const getTestRun = `-- name: GetTestRun :one
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE id = $1
`

func (q *Queries) GetTestRun(ctx context.Context, id uuid.UUID) (TestRun, error) {
	row := q.db.QueryRowContext(ctx, getTestRun, id)
	var i TestRun
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.TestPlanID,
		&i.TestCaseID,
		&i.OwnerID,
		&i.TestedByID,
		&i.AssignedToID,
		&i.AssigneeCanChangeCode,
		&i.Code,
		&i.ExternalIssueID,
		&i.ResultState,
		&i.IsClosed,
		&i.Notes,
		&i.ActualResult,
		&i.ExpectedResult,
		&i.Reactions,
		&i.TestedOn,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTesterCount = `-- name: GetTesterCount :one
SELECT COUNT(DISTINCT user_id) FROM project_testers WHERE is_active = true
`

func (q *Queries) GetTesterCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTesterCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTesterCountByProject = `-- name: GetTesterCountByProject :one
SELECT COUNT(DISTINCT user_id) FROM project_testers WHERE project_id = $1 AND is_active = true
`

func (q *Queries) GetTesterCountByProject(ctx context.Context, projectID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTesterCountByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTestersByID = `-- name: GetTestersByID :one
SELECT
project_testers.id, project_testers.project_id, project_testers.user_id, project_testers.role, project_testers.is_active, project_testers.created_at, project_testers.updated_at,
p.title as project,
u.display_name as tester_name,
u.last_login_at as tester_last_login_at
FROM project_testers
INNER JOIN users u ON u.id = project_testers.user_id
INNER JOIN projects p ON p.id = project_testers.project_id
WHERE project_id = $1
`

type GetTestersByIDRow struct {
	ID                int32
	ProjectID         int32
	UserID            int32
	Role              string
	IsActive          bool
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	Project           string
	TesterName        sql.NullString
	TesterLastLoginAt sql.NullTime
}

func (q *Queries) GetTestersByID(ctx context.Context, projectID int32) (GetTestersByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTestersByID, projectID)
	var i GetTestersByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.Role,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Project,
		&i.TesterName,
		&i.TesterLastLoginAt,
	)
	return i, err
}

const getTestersByProject = `-- name: GetTestersByProject :many
SELECT
project_testers.id, project_testers.project_id, project_testers.user_id, project_testers.role, project_testers.is_active, project_testers.created_at, project_testers.updated_at,
p.title as project,
u.display_name as tester_name,
u.last_login_at as tester_last_login_at
FROM project_testers
INNER JOIN users u ON u.id = project_testers.user_id
INNER JOIN projects p ON p.id = project_testers.project_id
WHERE project_id = $1
`

type GetTestersByProjectRow struct {
	ID                int32
	ProjectID         int32
	UserID            int32
	Role              string
	IsActive          bool
	CreatedAt         sql.NullTime
	UpdatedAt         sql.NullTime
	Project           string
	TesterName        sql.NullString
	TesterLastLoginAt sql.NullTime
}

func (q *Queries) GetTestersByProject(ctx context.Context, projectID int32) ([]GetTestersByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTestersByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTestersByProjectRow
	for rows.Next() {
		var i GetTestersByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Project,
			&i.TesterName,
			&i.TesterLastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, first_name, last_name, display_name, email, password, phone, org_id, country_iso, city, address, is_activated, is_reviewed, is_super_admin, is_verified, last_login_at, email_confirmed_at, created_at, updated_at, deleted_at FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.DisplayName,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.OrgID,
		&i.CountryIso,
		&i.City,
		&i.Address,
		&i.IsActivated,
		&i.IsReviewed,
		&i.IsSuperAdmin,
		&i.IsVerified,
		&i.LastLoginAt,
		&i.EmailConfirmedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const initTestCaseSequence = `-- name: InitTestCaseSequence :exec
INSERT INTO test_case_sequences (project_id, prefix, current_val, last_generated_at)
VALUES ($1, $2, 0, now())
ON CONFLICT (project_id, prefix) DO NOTHING
`

type InitTestCaseSequenceParams struct {
	ProjectID int32
	Prefix    string
}

func (q *Queries) InitTestCaseSequence(ctx context.Context, arg InitTestCaseSequenceParams) error {
	_, err := q.db.ExecContext(ctx, initTestCaseSequence, arg.ProjectID, arg.Prefix)
	return err
}

const isTestCaseLinkedToProject = `-- name: IsTestCaseLinkedToProject :one
SELECT EXISTS(
    SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE project_id = $1
)
`

func (q *Queries) IsTestCaseLinkedToProject(ctx context.Context, projectID sql.NullInt32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTestCaseLinkedToProject, projectID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isTestCaseUsedInTestPlan = `-- name: IsTestCaseUsedInTestPlan :one
SELECT EXISTS(
    SELECT 1 FROM test_runs WHERE test_case_id = $1
)
`

func (q *Queries) IsTestCaseUsedInTestPlan(ctx context.Context, testCaseID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTestCaseUsedInTestPlan, testCaseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isTestCaseUsedInTestRun = `-- name: IsTestCaseUsedInTestRun :one
SELECT EXISTS(
    SELECT 1 FROM test_runs WHERE test_case_id = $1
)
`

func (q *Queries) IsTestCaseUsedInTestRun(ctx context.Context, testCaseID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, isTestCaseUsedInTestRun, testCaseID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listProjects = `-- name: ListProjects :many
SELECT id, title, description, version, is_active, is_public, website_url, github_url, trello_url, jira_url, monday_url, owner_user_id, created_at, updated_at, deleted_at, code FROM projects ORDER BY created_at DESC
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Version,
			&i.IsActive,
			&i.IsPublic,
			&i.WebsiteUrl,
			&i.GithubUrl,
			&i.TrelloUrl,
			&i.JiraUrl,
			&i.MondayUrl,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCases = `-- name: ListTestCases :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases ORDER BY created_at DESC
`

func (q *Queries) ListTestCases(ctx context.Context) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesByCreator = `-- name: ListTestCasesByCreator :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE created_by_id = $1
`

func (q *Queries) ListTestCasesByCreator(ctx context.Context, createdByID int32) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCasesByCreator, createdByID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesByPlan = `-- name: ListTestCasesByPlan :many
SELECT tc.id, tc.kind, tc.code, tc.feature_or_module, tc.title, tc.description, tc.parent_test_case_id, tc.is_draft, tc.tags, tc.created_by_id, tc.created_at, tc.updated_at, tc.project_id FROM test_cases tc 
INNER JOIN test_plans_cases tp ON tp.test_case_id = tc.id  
WHERE tp.test_plan_id = $1
`

func (q *Queries) ListTestCasesByPlan(ctx context.Context, testPlanID uuid.UUID) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCasesByPlan, testPlanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestCasesByProject = `-- name: ListTestCasesByProject :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases WHERE project_id = $1
`

func (q *Queries) ListTestCasesByProject(ctx context.Context, projectID sql.NullInt32) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, listTestCasesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestPlans = `-- name: ListTestPlans :many
SELECT id, project_id, assigned_to_id, created_by_id, updated_by_id, kind, description, start_at, closed_at, scheduled_end_at, num_test_cases, num_failures, is_complete, is_locked, has_report, created_at, updated_at FROM test_plans ORDER BY created_at DESC
`

func (q *Queries) ListTestPlans(ctx context.Context) ([]TestPlan, error) {
	rows, err := q.db.QueryContext(ctx, listTestPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestPlan
	for rows.Next() {
		var i TestPlan
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.AssignedToID,
			&i.CreatedByID,
			&i.UpdatedByID,
			&i.Kind,
			&i.Description,
			&i.StartAt,
			&i.ClosedAt,
			&i.ScheduledEndAt,
			&i.NumTestCases,
			&i.NumFailures,
			&i.IsComplete,
			&i.IsLocked,
			&i.HasReport,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestPlansByProject = `-- name: ListTestPlansByProject :many
SELECT id, project_id, assigned_to_id, created_by_id, updated_by_id, kind, description, start_at, closed_at, scheduled_end_at, num_test_cases, num_failures, is_complete, is_locked, has_report, created_at, updated_at FROM test_plans WHERE project_id = $1
`

func (q *Queries) ListTestPlansByProject(ctx context.Context, projectID int32) ([]TestPlan, error) {
	rows, err := q.db.QueryContext(ctx, listTestPlansByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestPlan
	for rows.Next() {
		var i TestPlan
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.AssignedToID,
			&i.CreatedByID,
			&i.UpdatedByID,
			&i.Kind,
			&i.Description,
			&i.StartAt,
			&i.ClosedAt,
			&i.ScheduledEndAt,
			&i.NumTestCases,
			&i.NumFailures,
			&i.IsComplete,
			&i.IsLocked,
			&i.HasReport,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRuns = `-- name: ListTestRuns :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs ORDER BY created_at DESC
`

func (q *Queries) ListTestRuns(ctx context.Context) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsAssignedToUser = `-- name: ListTestRunsAssignedToUser :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE assigned_to_id = $1
`

func (q *Queries) ListTestRunsAssignedToUser(ctx context.Context, assignedToID int32) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsAssignedToUser, assignedToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsByOwner = `-- name: ListTestRunsByOwner :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE owner_id = $1
`

func (q *Queries) ListTestRunsByOwner(ctx context.Context, ownerID int32) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsByPlan = `-- name: ListTestRunsByPlan :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE test_plan_id = $1
`

func (q *Queries) ListTestRunsByPlan(ctx context.Context, testPlanID int32) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsByPlan, testPlanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTestRunsByProject = `-- name: ListTestRunsByProject :many
SELECT id, project_id, test_plan_id, test_case_id, owner_id, tested_by_id, assigned_to_id, assignee_can_change_code, code, external_issue_id, result_state, is_closed, notes, actual_result, expected_result, reactions, tested_on, created_at, updated_at FROM test_runs WHERE project_id = $1
`

func (q *Queries) ListTestRunsByProject(ctx context.Context, projectID int32) ([]TestRun, error) {
	rows, err := q.db.QueryContext(ctx, listTestRunsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestRun
	for rows.Next() {
		var i TestRun
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.TestPlanID,
			&i.TestCaseID,
			&i.OwnerID,
			&i.TestedByID,
			&i.AssignedToID,
			&i.AssigneeCanChangeCode,
			&i.Code,
			&i.ExternalIssueID,
			&i.ResultState,
			&i.IsClosed,
			&i.Notes,
			&i.ActualResult,
			&i.ExpectedResult,
			&i.Reactions,
			&i.TestedOn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, first_name, last_name, display_name, email, password, phone, org_id, country_iso, city, address, is_activated, is_reviewed, is_super_admin, is_verified, last_login_at, email_confirmed_at, created_at, updated_at, deleted_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.Email,
			&i.Password,
			&i.Phone,
			&i.OrgID,
			&i.CountryIso,
			&i.City,
			&i.Address,
			&i.IsActivated,
			&i.IsReviewed,
			&i.IsSuperAdmin,
			&i.IsVerified,
			&i.LastLoginAt,
			&i.EmailConfirmedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProject = `-- name: SearchProject :many
SELECT id, title, description, version, is_active, is_public, website_url, github_url, trello_url, jira_url, monday_url, owner_user_id, created_at, updated_at, deleted_at, code FROM projects
WHERE title ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchProject(ctx context.Context, dollar_1 sql.NullString) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, searchProject, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Version,
			&i.IsActive,
			&i.IsPublic,
			&i.WebsiteUrl,
			&i.GithubUrl,
			&i.TrelloUrl,
			&i.JiraUrl,
			&i.MondayUrl,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectTesters = `-- name: SearchProjectTesters :many
SELECT 
project_testers.id, project_testers.project_id, project_testers.user_id, project_testers.role, project_testers.is_active, project_testers.created_at, project_testers.updated_at,
u.display_name AS tester_name
FROM project_testers
INNER JOIN users u On u.id = project_testers.user_id
WHERE project_testers.role ILIKE '%' || $1 || '%'
`

type SearchProjectTestersRow struct {
	ID         int32
	ProjectID  int32
	UserID     int32
	Role       string
	IsActive   bool
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
	TesterName sql.NullString
}

func (q *Queries) SearchProjectTesters(ctx context.Context, dollar_1 sql.NullString) ([]SearchProjectTestersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProjectTesters, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProjectTestersRow
	for rows.Next() {
		var i SearchProjectTestersRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.UserID,
			&i.Role,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TesterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTestCases = `-- name: SearchTestCases :many
SELECT id, kind, code, feature_or_module, title, description, parent_test_case_id, is_draft, tags, created_by_id, created_at, updated_at, project_id FROM test_cases
WHERE title ILIKE '%' || $1 || '%'
OR code ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchTestCases(ctx context.Context, dollar_1 sql.NullString) ([]TestCase, error) {
	rows, err := q.db.QueryContext(ctx, searchTestCases, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCase
	for rows.Next() {
		var i TestCase
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Code,
			&i.FeatureOrModule,
			&i.Title,
			&i.Description,
			&i.ParentTestCaseID,
			&i.IsDraft,
			pq.Array(&i.Tags),
			&i.CreatedByID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, first_name, last_name, display_name, email, password, phone, org_id, country_iso, city, address, is_activated, is_reviewed, is_super_admin, is_verified, last_login_at, email_confirmed_at, created_at, updated_at, deleted_at FROM users 
WHERE first_name ILIKE '%' || $1 || '%'
OR last_name ILIKE '%' || $1 || '%'
OR display_name ILIKE '%' || $1 || '%'
OR email ILIKE '%' || $1 || '%'
`

func (q *Queries) SearchUsers(ctx context.Context, dollar_1 sql.NullString) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.DisplayName,
			&i.Email,
			&i.Password,
			&i.Phone,
			&i.OrgID,
			&i.CountryIso,
			&i.City,
			&i.Address,
			&i.IsActivated,
			&i.IsReviewed,
			&i.IsSuperAdmin,
			&i.IsVerified,
			&i.LastLoginAt,
			&i.EmailConfirmedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePage = `-- name: UpdatePage :exec
UPDATE pages SET parent_page_id = $2, page_version = $3, org_id = $4, project_id = $5, code = $6, title = $7, file_path = $8, content = $9, page_type = $10, mime_type = $11, has_embedded_media = $12, external_content_url = $13, notion_url = $14, last_edited_by = $15, created_by = $16
WHERE id = $1
`

type UpdatePageParams struct {
	ID                 int32
	ParentPageID       sql.NullInt32
	PageVersion        string
	OrgID              int32
	ProjectID          int32
	Code               string
	Title              string
	FilePath           sql.NullString
	Content            string
	PageType           string
	MimeType           string
	HasEmbeddedMedia   bool
	ExternalContentUrl sql.NullString
	NotionUrl          sql.NullString
	LastEditedBy       int32
	CreatedBy          int32
}

func (q *Queries) UpdatePage(ctx context.Context, arg UpdatePageParams) error {
	_, err := q.db.ExecContext(ctx, updatePage,
		arg.ID,
		arg.ParentPageID,
		arg.PageVersion,
		arg.OrgID,
		arg.ProjectID,
		arg.Code,
		arg.Title,
		arg.FilePath,
		arg.Content,
		arg.PageType,
		arg.MimeType,
		arg.HasEmbeddedMedia,
		arg.ExternalContentUrl,
		arg.NotionUrl,
		arg.LastEditedBy,
		arg.CreatedBy,
	)
	return err
}

const updateProject = `-- name: UpdateProject :execrows
UPDATE projects SET 
title = $2, description = $3, website_url = $4,
version = $5, github_url = $6, 
owner_user_id = $7
WHERE id = $1
`

type UpdateProjectParams struct {
	ID          int32
	Title       string
	Description string
	WebsiteUrl  sql.NullString
	Version     sql.NullString
	GithubUrl   sql.NullString
	OwnerUserID int32
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProject,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.WebsiteUrl,
		arg.Version,
		arg.GithubUrl,
		arg.OwnerUserID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProjectModule = `-- name: UpdateProjectModule :exec
UPDATE modules SET name = $2, code = $3, priority = $4, type = $5, description = $6
WHERE id = $1
`

type UpdateProjectModuleParams struct {
	ID          int32
	Name        string
	Code        string
	Priority    int32
	Type        string
	Description string
}

func (q *Queries) UpdateProjectModule(ctx context.Context, arg UpdateProjectModuleParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectModule,
		arg.ID,
		arg.Name,
		arg.Code,
		arg.Priority,
		arg.Type,
		arg.Description,
	)
	return err
}

const updateTestCase = `-- name: UpdateTestCase :exec
UPDATE test_cases SET
kind = $2,
code = $3,
feature_or_module = $4,
title = $5,
description = $6,
is_draft = $7,
tags = $8,
updated_at = $9
WHERE id = $1
`

type UpdateTestCaseParams struct {
	ID              uuid.UUID
	Kind            TestKind
	Code            string
	FeatureOrModule sql.NullString
	Title           string
	Description     string
	IsDraft         sql.NullBool
	Tags            []string
	UpdatedAt       sql.NullTime
}

func (q *Queries) UpdateTestCase(ctx context.Context, arg UpdateTestCaseParams) error {
	_, err := q.db.ExecContext(ctx, updateTestCase,
		arg.ID,
		arg.Kind,
		arg.Code,
		arg.FeatureOrModule,
		arg.Title,
		arg.Description,
		arg.IsDraft,
		pq.Array(arg.Tags),
		arg.UpdatedAt,
	)
	return err
}

const updateTestPlan = `-- name: UpdateTestPlan :exec
UPDATE test_plans SET project_id = $2, assigned_to_id = $3, created_by_id = $4,
updated_by_id = $5, kind = $6, description = $7, start_at = $8,
closed_at = $9, scheduled_end_at = $10, num_test_cases = $11,
num_failures = $12, is_complete = $13, is_locked = $14,
has_report = $15, created_at = $16, updated_at = $17
WHERE id = $1
`

type UpdateTestPlanParams struct {
	ID             int64
	ProjectID      int32
	AssignedToID   int32
	CreatedByID    int32
	UpdatedByID    int32
	Kind           TestKind
	Description    sql.NullString
	StartAt        sql.NullTime
	ClosedAt       sql.NullTime
	ScheduledEndAt sql.NullTime
	NumTestCases   int32
	NumFailures    int32
	IsComplete     sql.NullBool
	IsLocked       sql.NullBool
	HasReport      sql.NullBool
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
}

func (q *Queries) UpdateTestPlan(ctx context.Context, arg UpdateTestPlanParams) error {
	_, err := q.db.ExecContext(ctx, updateTestPlan,
		arg.ID,
		arg.ProjectID,
		arg.AssignedToID,
		arg.CreatedByID,
		arg.UpdatedByID,
		arg.Kind,
		arg.Description,
		arg.StartAt,
		arg.ClosedAt,
		arg.ScheduledEndAt,
		arg.NumTestCases,
		arg.NumFailures,
		arg.IsComplete,
		arg.IsLocked,
		arg.HasReport,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET 
    first_name = $2, last_name = $3, display_name = $4, phone = $5,
    org_id = $6, country_iso = $7, city = $8, address = $9,
    is_activated = $10, is_reviewed = $11, is_super_admin = $12, is_verified = $13,
    last_login_at = $14, email_confirmed_at = $15, created_at = $16, updated_at = $17, deleted_at = $18
WHERE id = $1
`

type UpdateUserParams struct {
	ID               int32
	FirstName        string
	LastName         string
	DisplayName      sql.NullString
	Phone            string
	OrgID            sql.NullInt32
	CountryIso       string
	City             sql.NullString
	Address          string
	IsActivated      sql.NullBool
	IsReviewed       sql.NullBool
	IsSuperAdmin     sql.NullBool
	IsVerified       sql.NullBool
	LastLoginAt      sql.NullTime
	EmailConfirmedAt sql.NullTime
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	DeletedAt        sql.NullTime
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.DisplayName,
		arg.Phone,
		arg.OrgID,
		arg.CountryIso,
		arg.City,
		arg.Address,
		arg.IsActivated,
		arg.IsReviewed,
		arg.IsSuperAdmin,
		arg.IsVerified,
		arg.LastLoginAt,
		arg.EmailConfirmedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :execrows
UPDATE users SET last_login_at = $1 WHERE id = $2 AND is_activated AND deleted_at IS NULL
`

type UpdateUserLastLoginParams struct {
	LastLoginAt sql.NullTime
	ID          int32
}

func (q *Queries) UpdateUserLastLogin(ctx context.Context, arg UpdateUserLastLoginParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateUserLastLogin, arg.LastLoginAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const userExists = `-- name: UserExists :one
SELECT EXISTS(SELECT id FROM users WHERE id = $1)
`

func (q *Queries) UserExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, userExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
